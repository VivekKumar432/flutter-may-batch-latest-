https://user-images.githubusercontent.com/60808266/101982867-15518f80-3ca1-11eb-816f-cda1557ac646.png


CUBIT IMPLEMENT

1. Create a Cubit
e.g Your class must extend the cubit class, and cubit class requires the state (On Which type value is going to store>
1.1 class CounterCubit extends Cubit<CounterState>

If complex type so define your custom class.
class CounterState{
int x, y, z;
}

e.g if state is simple type
Class CounterCubit extends Cubit<int>{}

1.2 Constructor call and initialise the state.
Complex type / custom type initialise 
CounterCubit()
      : super(CounterState(0, 0, 0)) {}

If simple type
e.g CounterCubit(): super(0);

1.3 Create the Operations (Methods) who change in the state.
e.g Complex type
plus(int z) {
    emit(CounterState(state.x + 1, state.y + 2, state.z + 3 * z));
  }

e.g Simple type
plus(int z) {
    emit(CounterState(state+1));
  }

After Cubit creation move to the 2nd Step. Provide the Cubit on which level.
Using Provider (BlocProvider) we create the object of Cubit and give it to the Widget. So it will be available down the tree.
void main() {
  runApp(MaterialApp(
      home: BlocProvider<CounterCubit>(
    create: (ctx) =>
        CounterCubit(), // Cubit Object created Here and supply to the CounterPageWidget
    child: CounterPage(),
  )));
}


Step-3 Consuming the Cubit Methods and Data
3.1 A Widget can call the Cubit methods.
CounterCubit obj =
        BlocProvider.of<CounterCubit>(ctx); // Access the Cubit Object
    obj.plus(5); // Call the Plus Method of Counter Cubit

3.2 A Widget can consume the state generated by the cubit.
Widget build(BuildContext context) {
    return BlocBuilder<CounterCubit, CounterState>(
      builder: (ctx, state) {
        return Text(
          'Output ${state.x} ${state.y} ${state.z} ',
          style: TextStyle(fontSize: 40),
        );
      },
    );
  }













